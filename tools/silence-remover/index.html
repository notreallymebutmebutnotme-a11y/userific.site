<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Silence Remover ‚Äì MP3/WAV | Userific</title>
  <meta name="description" content="Remove silence from MP3/WAV audio files online. Free, no login required. Perfect for podcasts, voiceovers, lectures, and music editing.">
  <meta name="keywords" content="silence remover, cut silence mp3, remove gaps audio, podcast silence cutter, voiceover silence remover, free audio editing, no login audio tool, automatic silence detection, audio cleanup, Userific">
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap" rel="stylesheet">

  <style>
    :root {
      --gradient-dark: linear-gradient(135deg, #0f2027, #203a43, #2c5364);
      --gradient-light: linear-gradient(135deg, #fdfbfb 0%, #ebedee 100%);
      --card-dark: rgba(30,30,30,0.9);
      --card-light: rgba(255,255,255,0.95);
      --primary: #2a7cff;
    }
    *{margin:0;padding:0;box-sizing:border-box;font-family:'Poppins',sans-serif;}
    body{min-height:100vh;background:var(--gradient-dark);color:#f5f5f5;display:flex;flex-direction:column;}
    body.light{background:var(--gradient-light);color:#111;}
    header{padding:15px 20px;display:flex;justify-content:space-between;align-items:center;}
    header h1{font-size:1.6rem;font-weight:700;margin-bottom:2px;}
    header h1 a{text-decoration:none;color:inherit;}
    header .tagline{font-size:0.9rem;font-weight:400;opacity:0.9;}
    .toggle{cursor:pointer;font-size:1.5rem;background:transparent;border:none;outline:none;line-height:1;}
    .toggle:hover,.toggle:focus{opacity:0.9;text-decoration:none;}
    main{flex:1;max-width:900px;margin:1rem auto;padding:1rem;width:100%;}
    .ads{margin:1rem 0;padding:1rem;border:2px dashed #777;border-radius:12px;text-align:center;font-size:0.9rem;}
    .card{background:var(--card-dark);border-radius:16px;padding:20px;box-shadow:0 4px 12px rgba(0,0,0,0.3);}
    body.light .card{background:var(--card-light);}
    label{display:block;font-size:0.9rem;margin:12px 0 6px;}
    input[type=file], select, button{width:100%;padding:12px;border-radius:12px;border:1px solid #ccc;font-size:1rem;margin-bottom:12px;}
    button{background:var(--primary);color:#fff;font-weight:600;cursor:pointer;border:none;}
    button:disabled{opacity:0.6;cursor:not-allowed;}
    input[type=range]{width:100%;}
    .row{display:grid;grid-template-columns:1fr 100px;gap:12px;align-items:center;}
    .val{text-align:right;font-size:0.9rem;}
    #out{margin-top:1rem;padding:12px;border-radius:12px;background:rgba(0,0,0,0.3);min-height:60px;white-space:pre-wrap;}
    a.dl{display:inline-block;margin-top:12px;padding:10px 14px;border-radius:10px;background:#18222a;color:#cfeaff;text-decoration:none;font-weight:600;}
    footer{text-align:center;padding:1rem;font-size:0.85rem;margin-top:2rem;}
    footer a{color:inherit;text-decoration:underline;margin:0 5px;}
  </style>

  <!-- MP3 encoder (lazy-loaded when needed) -->
  <script>
    let lameLoaded = false;
    async function ensureLame() {
      if (lameLoaded) return true;
      return new Promise((resolve, reject) => {
        const s = document.createElement('script');
        s.src = 'https://unpkg.com/lamejs@1.2.0/lame.min.js';
        s.onload = () => { lameLoaded = true; resolve(true); };
        s.onerror = () => reject(new Error('Failed to load MP3 encoder.'));
        document.head.appendChild(s);
      });
    }
  </script>
</head>
<body class="dark">
  <header>
    <div>
      <h1><a href="/">Userific</a></h1>
      <div class="tagline">Useful tools built just for you ‚ú®</div>
    </div>
    <button class="toggle" id="themeToggle" aria-label="Toggle theme">üåó</button>
  </header>

  <main>
    <h1 style="text-align:center;margin-bottom:8px;">Silence Remover</h1>
    <p style="text-align:center;opacity:0.9;">Upload an MP3 or WAV. This tool automatically trims long silences and keeps a short natural gap. Works locally in your browser. No login required.</p>

    <div class="ads">Ads will show here</div>

    <div class="card">
      <label>Choose MP3/WAV file</label>
      <input id="file" type="file" accept=".mp3,.wav,audio/*" />

      <div class="row">
        <div>
          <label>Silence threshold (dBFS)</label>
          <input id="thresh" type="range" min="-80" max="-10" step="1" value="-45">
        </div>
        <div class="val"><span id="threshVal">-45</span> dB</div>
      </div>

      <div class="row">
        <div>
          <label>Minimum silence to cut (seconds)</label>
          <input id="minsil" type="range" min="0.1" max="2.0" step="0.1" value="0.3">
        </div>
        <div class="val"><span id="minsilVal">0.3</span> s</div>
      </div>

      <div class="row">
        <div>
          <label>Keep gap after cut (seconds)</label>
          <input id="keepgap" type="range" min="0.2" max="1.0" step="0.1" value="0.5">
        </div>
        <div class="val"><span id="keepVal">0.5</span> s</div>
      </div>

      <div class="row" style="grid-template-columns:1fr 1fr 1fr;gap:10px;">
        <button id="analyze">Analyze</button>
        <select id="format">
          <option value="mp3" selected>Export: MP3 (128 kbps)</option>
          <option value="wav">Export: WAV (lossless)</option>
        </select>
        <button id="process" disabled>Cut & Export</button>
      </div>

      <div id="out">Ready.</div>
      <div id="links"></div>
      <p class="small" style="opacity:0.8;margin-top:10px;">Tip: If words get chopped, lower the threshold (e.g., ‚àí50 dB) or increase ‚ÄúMinimum silence‚Äù.</p>
    </div>

    <div class="ads">Ads will show here</div>
  </main>

  <footer>
    <p>&copy; <span id="year"></span> Userific.xyz ‚Äì All Rights Reserved</p>
    <p><a href="/privacy.html">Privacy Policy</a> | <a href="/terms.html">Terms</a> | <a href="/contact.html">Contact</a></p>
  </footer>

  <script>
    document.getElementById("year").textContent=new Date().getFullYear();
    const themeToggle=document.getElementById("themeToggle");
    themeToggle.addEventListener("click",()=>{
      document.body.classList.toggle("light");
      themeToggle.textContent=document.body.classList.contains("light")?'üåô':'üåó';
    });
  </script>

  <!-- Silence remover logic -->
  <script>
    const fileInput = document.getElementById("file");
    const analyzeBtn = document.getElementById("analyze");
    const processBtn = document.getElementById("process");
    const out = document.getElementById("out");
    const links = document.getElementById("links");
    const threshSlider = document.getElementById("thresh");
    const minSilSlider = document.getElementById("minsil");
    const keepGapSlider = document.getElementById("keepgap");
    const threshVal = document.getElementById("threshVal");
    const minSilVal = document.getElementById("minsilVal");
    const keepVal = document.getElementById("keepVal");
    const formatSelect = document.getElementById("format");

    let audioCtx = null;
    let audioBuffer = null;
    let cuts = [];

    threshSlider.oninput = () => { threshVal.textContent = threshSlider.value; };
    minSilSlider.oninput = () => { minSilVal.textContent = minSilSlider.value; };
    keepGapSlider.oninput = () => { keepVal.textContent = keepGapSlider.value; };

    async function decodeFile(file) {
      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      const arrayBuffer = await file.arrayBuffer();
      return new Promise((resolve, reject) => {
        audioCtx.decodeAudioData(arrayBuffer.slice(0), resolve, reject);
      });
    }

    function dbfs(rms) {
      return 20 * Math.log10(rms || 1e-10);
    }

    function analyzeBuffer(buffer, threshold, minSil) {
      const data = buffer.getChannelData(0);
      const sr = buffer.sampleRate;
      const winSize = Math.floor(0.02 * sr); // 20 ms
      const hop = winSize;
      let silStart = null;
      const found = [];

      for (let i = 0; i < data.length; i += hop) {
        let sum = 0;
        const end = Math.min(i + winSize, data.length);
        for (let j = i; j < end; j++) sum += data[j] * data[j];
        const rms = Math.sqrt(sum / Math.max(1, end - i));
        const level = dbfs(rms);

        if (level < threshold) {
          if (silStart === null) silStart = i;
        } else if (silStart !== null) {
          const dur = (i - silStart) / sr;
          if (dur >= minSil) found.push([silStart / sr, i / sr]);
          silStart = null;
        }
      }
      if (silStart !== null) {
        const dur = (data.length - silStart) / sr;
        if (dur >= minSil) found.push([silStart / sr, data.length / sr]);
      }
      return found;
    }

    fileInput.onchange = async () => {
      const f = fileInput.files[0];
      if (!f) return;
      try {
        out.textContent = "Loading audio‚Ä¶";
        audioBuffer = await decodeFile(f);
        out.textContent = `Loaded ${f.name} (${audioBuffer.duration.toFixed(1)}s)`;
        processBtn.disabled = true;
        cuts = [];
      } catch (err) {
        console.error(err);
        out.textContent = "Failed to decode audio. Try a different file.";
      }
    };

    analyzeBtn.onclick = () => {
      if (!audioBuffer) { alert("Choose an audio file first."); return; }
      const threshold = parseFloat(threshSlider.value);
      const minSil = parseFloat(minSilSlider.value);
      cuts = analyzeBuffer(audioBuffer, threshold, minSil);
      out.textContent = `Found ${cuts.length} silent segments. Ready to process.`;
      processBtn.disabled = false;
    };

    processBtn.onclick = async () => {
      if (!audioBuffer) return;
      try {
        out.textContent = "Processing‚Ä¶ this may take a while.";
        const threshold = parseFloat(threshSlider.value);
        const minSil = parseFloat(minSilSlider.value);
        const keepGap = parseFloat(keepGapSlider.value);
        cuts = analyzeBuffer(audioBuffer, threshold, minSil);

        const sr = audioBuffer.sampleRate;
        const segments = [];
        let last = 0;

        for (const [s, e] of cuts) {
          const start = Math.max(0, last);
          let end = Math.max(start, s - keepGap);
          if (end - start > 0.01) { // keep only >10ms
            segments.push([start, end]);
          }
          last = e + keepGap;
        }
        if (last < audioBuffer.duration) {
          segments.push([last, audioBuffer.duration]);
        }
        if (segments.length === 0) {
          segments.push([0, audioBuffer.duration]); // fallback
        }

        const totalSamples = segments.reduce((sum, [a, b]) => sum + Math.max(0, Math.floor((b - a) * sr)), 0);
        if (totalSamples <= 0) {
          out.textContent = "No audio left after silence removal. Try adjusting settings.";
          return;
        }

        const offline = new (window.OfflineAudioContext || window.webkitOfflineAudioContext)(1, totalSamples, sr);
        const outBuf = offline.createBuffer(1, totalSamples, sr);
        const src = audioBuffer.getChannelData(0);
        const dst = outBuf.getChannelData(0);
        let pos = 0;
        for (const [a, b] of segments) {
          const A = Math.max(0, Math.floor(a * sr));
          const B = Math.max(A, Math.floor(b * sr));
          const len = B - A;
          if (len > 0) {
            dst.set(src.subarray(A, B), pos);
            pos += len;
          }
        }

        links.innerHTML = "";
        const format = formatSelect.value;
        if (format === "wav") {
          const wav = audioBufferToWav(outBuf);
          const blob = new Blob([wav], { type: "audio/wav" });
          makeDownloadLink(blob, "silence-removed.wav");
        } else {
          await ensureLame();
          const mp3blob = encodeMp3(outBuf, 128);
          makeDownloadLink(mp3blob, "silence-removed.mp3");
        }
        out.textContent = "Done! Your file is ready.";
      } catch (err) {
        console.error(err);
        out.textContent = "Processing failed. Try adjusting settings or a smaller file.";
      }
    };

    function makeDownloadLink(blob, name) {
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = name;
      a.textContent = "Download " + name;
      a.className = "dl";
      links.innerHTML = "";
      links.appendChild(a);
    }

    function audioBufferToWav(buffer) {
      const samples = buffer.getChannelData(0);
      const sr = buffer.sampleRate;
      const dataSize = samples.length * 2;
      const bufferLength = 44 + dataSize;
      const ab = new ArrayBuffer(bufferLength);
      const view = new DataView(ab);
      let offset = 0;
      function writeString(s) { for (let i=0;i<s.length;i++) view.setUint8(offset++, s.charCodeAt(i)); }
      function write16(v) { view.setUint16(offset, v, true); offset += 2; }
      function write32(v) { view.setUint32(offset, v, true); offset += 4; }

      writeString("RIFF");
      write32(36 + dataSize);
      writeString("WAVE");
      writeString("fmt ");
      write32(16);
      write16(1);
      write16(1);
      write32(sr);
      write32(sr*2);
      write16(2);
      write16(16);
      writeString("data");
      write32(dataSize);

      for (let i = 0; i < samples.length; i++) {
        let s = Math.max(-1, Math.min(1, samples[i]));
        view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
        offset += 2;
      }
      return ab;
    }

    function encodeMp3(buffer, kbps = 128) {
      const sr = buffer.sampleRate;
      const samples = buffer.getChannelData(0);
      const mp3encoder = new lamejs.Mp3Encoder(1, sr, kbps);
      const maxSamples = 1152;
      const mp3Data = [];
      for (let i = 0; i < samples.length; i += maxSamples) {
        const slice = samples.subarray(i, i + maxSamples);
        const pcm = new Int16Array(slice.length);
        for (let j = 0; j < slice.length; j++) {
          const s = Math.max(-1, Math.min(1, slice[j]));
          pcm[j] = s < 0 ? s * 0x8000 : s * 0x7FFF;
        }
        const enc = mp3encoder.encodeBuffer(pcm);
        if (enc.length > 0) mp3Data.push(enc);
      }
      const end = mp3encoder.flush();
      if (end.length > 0) mp3Data.push(end);
      return new Blob(mp3Data, { type: "audio/mpeg" });
    }
  </script>
</body>
</html>
