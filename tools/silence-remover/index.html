<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Silence Cutter (Keep 0.5s) — WAV/MP3</title>
  <style>
    :root { --bg:#0b0b0c; --card:#141416; --text:#e8e9ee; --muted:#9aa0a6; --accent:#62d4ff; }
    *{ box-sizing:border-box; }
    body{ margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Ubuntu,Arial,sans-serif; background:var(--bg); color:var(--text); }
    .wrap{ max-width:800px; margin:32px auto; padding:0 16px; }
    .card{ background:var(--card); border:1px solid #1f2022; border-radius:16px; padding:18px; box-shadow:0 10px 30px rgba(0,0,0,.35); }
    h1{ font-size:20px; margin:0 0 10px; letter-spacing:.3px; }
    p.hint{ color:var(--muted); margin:6px 0 14px; font-size:14px; }
    label{ display:block; font-size:14px; color:var(--muted); margin:14px 0 8px; }
    input[type="file"]{ width:100%; padding:12px; border:1px dashed #2b2c30; border-radius:12px; background:#111; color:var(--text); }
    .row{ display:grid; grid-template-columns:1fr 120px; gap:12px; align-items:center; }
    input[type="range"]{ width:100%; }
    .val{ text-align:right; font-variant-numeric:tabular-nums; }
    .row2{ display:grid; grid-template-columns:repeat(3,1fr); gap:10px; }
    select, button{ width:100%; padding:12px 14px; border-radius:12px; border:1px solid #2a2b2f; background:#0f1114; color:var(--text); font-weight:600; cursor:pointer; }
    button.primary{ background:linear-gradient(135deg,#2a7cff,#1cc8ff); border:none; color:#00121a; }
    button:disabled{ opacity:.6; cursor:not-allowed; }
    .out{ margin-top:14px; padding:12px; font-size:13px; color:#cfd3dc; border:1px solid #222; border-radius:12px; background:#101114; min-height:52px; white-space:pre-wrap; }
    a.dl{ display:inline-block; margin-top:12px; padding:10px 12px; border-radius:10px; background:#18222a; border:1px solid #25303a; color:#cfeaff; text-decoration:none; font-weight:600; }
    .small{ font-size:12px; color:#98a1ab; }
  </style>
  <!-- MP3 encoding via lamejs (loaded from CDN only when needed) -->
  <script>
    let lameLoaded = false;
    async function ensureLame() {
      if (lameLoaded) return true;
      return new Promise((resolve, reject) => {
        const s = document.createElement('script');
        s.src = 'https://unpkg.com/lamejs@1.2.0/lame.min.js';
        s.onload = () => { lameLoaded = true; resolve(true); };
        s.onerror = () => reject(new Error('Failed to load MP3 encoder (lamejs). Check internet connection.'));
        document.head.appendChild(s);
      });
    }
  </script>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <h1>Silence Cutter — keep 0.5s gaps (WAV/MP3)</h1>
      <p class="hint">Upload an MP3 voice file. This tool removes long silences and leaves exactly <b>0.5 seconds</b> where cuts are made. Export as <b>MP3</b> (small size) or <b>WAV</b> (lossless). If MP3 export is chosen, the encoder script loads from a CDN.</p>

      <label>Choose MP3 file</label>
      <input id="file" type="file" accept=".mp3,audio/mpeg,audio/mp3" />

      <div class="row">
        <div>
          <label>Silence threshold (dBFS)</label>
          <input id="thresh" type="range" min="-80" max="-10" step="1" value="-45">
        </div>
        <div class="val"><span id="threshVal">-45</span> dB</div>
      </div>

      <div class="row">
        <div>
          <label>Minimum silence to cut (seconds)</label>
          <input id="minsil" type="range" min="0.1" max="2.0" step="0.1" value="0.3">
        </div>
        <div class="val"><span id="minsilVal">0.3</span> s</div>
      </div>

      <div class="row">
        <div>
          <label>Keep gap after each cut (seconds)</label>
          <input id="keepgap" type="range" min="0.2" max="1.0" step="0.1" value="0.5">
        </div>
        <div class="val"><span id="keepVal">0.5</span> s</div>
      </div>

      <div class="row2">
        <button id="analyze">Analyze</button>
        <select id="format">
          <option value="mp3" selected>Export: MP3 (small)</option>
          <option value="wav">Export: WAV (lossless)</option>
        </select>
        <button class="primary" id="process" disabled>Cut & Export</button>
      </div>

      <div id="out" class="out">Ready.</div>
      <div id="links"></div>
      <p class="small">Tip: If you hear words getting chopped, lower the threshold (e.g., −50 dB) or increase “Minimum silence”. MP3 uses 128 kbps by default.</p>
    </div>
  </div>

<script>
(() => {
  const fileEl = document.getElementById('file');
  const analyzeBtn = document.getElementById('analyze');
  const processBtn = document.getElementById('process');
  const outEl = document.getElementById('out');
  const linksEl = document.getElementById('links');
  const thresh = document.getElementById('thresh');
  const threshVal = document.getElementById('threshVal');
  const minsil = document.getElementById('minsil');
  const minsilVal = document.getElementById('minsilVal');
  const keepgap = document.getElementById('keepgap');
  const keepVal = document.getElementById('keepVal');
  const fmtSel = document.getElementById('format');

  thresh.addEventListener('input', ()=>threshVal.textContent = thresh.value);
  minsil.addEventListener('input', ()=>minsilVal.textContent = minsil.value);
  keepgap.addEventListener('input', ()=>keepVal.textContent = keepgap.value);

  let audioBuffer = null;
  let segments = []; // [{start,end,type}] in samples

  function log(msg){ outEl.textContent = msg; }
  function fmtTime(sec){
    const m = Math.floor(sec/60);
    const s = sec - m*60;
    return `${m}:${s.toFixed(2).padStart(5,'0')}`;
  }

  async function decodeFile(file){
    const arrbuf = await file.arrayBuffer();
    const ctx = new (window.AudioContext || window.webkitAudioContext)();
    try{
      const buf = await ctx.decodeAudioData(arrbuf);
      ctx.close();
      return buf;
    }catch(e){
      ctx.close();
      throw e;
    }
  }

  function dbToLin(db){ return Math.pow(10, db/20); }

  function analyzeBuffer(buf, thrDb, minSilSec){
    const sr = buf.sampleRate;
    const ch = buf.numberOfChannels;
    const len = buf.length;

    const frameSize = Math.floor(sr * 0.01); // 10ms
    const hop = frameSize;
    const minSilFrames = Math.max(1, Math.floor((minSilSec * sr) / hop));
    const thr = dbToLin(thrDb); // 0..1

    const frames = Math.ceil(len / hop);
    const peaks = new Float32Array(frames);
    const tmp = new Float32Array(frameSize);

    let f = 0;
    for(let i=0; i<len; i += hop){
      const size = Math.min(frameSize, len - i);
      let peak = 0;
      for(let c=0;c<ch;c++){
        buf.copyFromChannel(tmp.subarray(0,size), c, i);
        for(let j=0;j<size;j++){
          const v = Math.abs(tmp[j]);
          if(v > peak) peak = v;
        }
      }
      peaks[f++] = peak;
    }

    const isSilent = Array.from(peaks, v => v < thr);

    const segs = [];
    let i = 0;
    while(i < frames){
      // consume non-silent
      let startFrame = i;
      while(i < frames && !isSilent[i]) i++;
      let silStart = i;
      while(i < frames && isSilent[i]) i++;
      let silEnd = i;
      const silLen = silEnd - silStart;

      if(silLen >= minSilFrames){
        const startSample = startFrame * hop;
        const endSample   = silStart * hop;
        if(endSample > startSample) segs.push({start:startSample, end:endSample, type:'audio'});
        segs.push({start:0, end:0, type:'gap'});
      }else{
        const startSample = startFrame * hop;
        const endSample   = silEnd * hop;
        if(endSample > startSample) segs.push({start:startSample, end:endSample, type:'audio'});
      }
    }
    return segs;
  }

  function estimateOutputSamples(segs, keepGapSec, sr){
    const gap = Math.floor(keepGapSec * sr);
    let total = 0;
    for(const s of segs){
      if(s.type==='audio') total += (s.end - s.start);
      else if(s.type==='gap') total += gap;
    }
    return total;
  }

  function stitchToBuffer(buf, segs, keepGapSec){
    const sr = buf.sampleRate;
    const ch = buf.numberOfChannels;
    const gapSamples = Math.floor(keepGapSec * sr);
    const total = estimateOutputSamples(segs, keepGapSec, sr);
    const out = new AudioBuffer({length: total, numberOfChannels: ch, sampleRate: sr});

    let writePos = 0;
    const tmp = new Float32Array(65536);

    for(const s of segs){
      if(s.type==='audio'){
        let remaining = s.end - s.start;
        let readPos = s.start;
        while(remaining > 0){
          const chunk = Math.min(remaining, tmp.length);
          for(let c=0;c<ch;c++){
            buf.copyFromChannel(tmp.subarray(0,chunk), c, readPos);
            out.copyToChannel(tmp.subarray(0,chunk), c, writePos);
          }
          writePos += chunk;
          readPos += chunk;
          remaining -= chunk;
        }
      }else if(s.type==='gap'){
        // zero-filled by default
        writePos += gapSamples;
      }
    }
    return out;
  }

  // --- WAV ENCODER (fixed header) ---
  function writeWAV(audioBuffer){
    const numChannels = audioBuffer.numberOfChannels;
    const sampleRate = audioBuffer.sampleRate;
    const length = audioBuffer.length;

    // Interleave
    const interleaved = new Float32Array(length * numChannels);
    let idx = 0;
    for(let i=0;i<length;i++){
      for(let c=0;c<numChannels;c++){
        interleaved[idx++] = audioBuffer.getChannelData(c)[i];
      }
    }
    // Float32 -> PCM16
    const pcm16 = new Int16Array(interleaved.length);
    for(let i=0;i<interleaved.length;i++){
      let s = Math.max(-1, Math.min(1, interleaved[i]));
      pcm16[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
    }

    const bytesPerSample = 2;
    const blockAlign = numChannels * bytesPerSample;
    const byteRate = sampleRate * blockAlign;
    const dataSize = pcm16.length * bytesPerSample;
    const buffer = new ArrayBuffer(44 + dataSize);
    const view = new DataView(buffer);
    let pos = 0;

    function writeString(s){
      for(let i=0;i<s.length;i++) view.setUint8(pos++, s.charCodeAt(i));
    }
    function writeUint32(v){ view.setUint32(pos, v, true); pos += 4; }
    function writeUint16(v){ view.setUint16(pos, v, true); pos += 2; }

    writeString('RIFF');
    writeUint32(36 + dataSize);
    writeString('WAVE');
    writeString('fmt ');
    writeUint32(16);           // PCM chunk size
    writeUint16(1);            // PCM format
    writeUint16(numChannels);
    writeUint32(sampleRate);
    writeUint32(byteRate);
    writeUint16(blockAlign);
    writeUint16(16);           // bits per sample
    writeString('data');
    writeUint32(dataSize);

    // PCM data
    new Int16Array(buffer, 44).set(pcm16);
    return new Blob([buffer], {type:'audio/wav'});
  }

  // --- MP3 ENCODER via lamejs ---
  function floatTo16(float32){
    const out = new Int16Array(float32.length);
    for(let i=0;i<float32.length;i++){
      let s = Math.max(-1, Math.min(1, float32[i]));
      out[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
    }
    return out;
  }

  function encodeMP3FromAudioBuffer(audioBuffer, kbps=128){
    if (typeof lamejs === 'undefined') throw new Error('lamejs not loaded');
    const numChannels = audioBuffer.numberOfChannels;
    const sampleRate = audioBuffer.sampleRate;
    const mp3encoder = new lamejs.Mp3Encoder(numChannels, sampleRate, kbps);

    const left = floatTo16(audioBuffer.getChannelData(0));
    const right = numChannels > 1 ? floatTo16(audioBuffer.getChannelData(1)) : null;

    const blockSize = 1152;
    let mp3Data = [];
    for(let i=0; i<left.length; i += blockSize){
      const l = left.subarray(i, i+blockSize);
      let mp3buf;
      if(numChannels === 2){
        const r = right.subarray(i, i+blockSize);
        mp3buf = mp3encoder.encodeBuffer(l, r);
      }else{
        mp3buf = mp3encoder.encodeBuffer(l);
      }
      if(mp3buf.length > 0) mp3Data.push(new Int8Array(mp3buf));
    }
    const end = mp3encoder.flush();
    if(end.length > 0) mp3Data.push(new Int8Array(end));
    return new Blob(mp3Data, {type:'audio/mpeg'});
  }

  let baseName = 'output';

  analyzeBtn.addEventListener('click', async () => {
    linksEl.innerHTML = '';
    const file = fileEl.files && fileEl.files[0];
    if(!file){ log('Please choose an MP3 file first.'); return; }
    baseName = (file.name.replace(/\.[^.]+$/,'') || 'output');
    log('Decoding audio…');
    analyzeBtn.disabled = true;
    processBtn.disabled = true;
    try{
      audioBuffer = await decodeFile(file);
      log(`Decoded: ${file.name}
Sample rate: ${audioBuffer.sampleRate} Hz • Channels: ${audioBuffer.numberOfChannels}
Duration: ${fmtTime(audioBuffer.duration)}
Analyzing for silences…`);

      segments = analyzeBuffer(audioBuffer, parseFloat(thresh.value), parseFloat(minsil.value));
      const gapCount = segments.filter(s => s.type==='gap').length;
      const outSamples = estimateOutputSamples(segments, parseFloat(keepgap.value), audioBuffer.sampleRate);
      const outDur = outSamples / audioBuffer.sampleRate;

      log(`Analysis done.
Detected ${gapCount} long-silence cut(s).
Estimated output duration: ${fmtTime(outDur)}.
Press “Cut & Export”.`);
      processBtn.disabled = false;
    }catch(e){
      console.error(e);
      log('Failed to decode/analyze this file. Ensure it is a valid MP3. Details in console.');
    }finally{
      analyzeBtn.disabled = false;
    }
  });

  processBtn.addEventListener('click', async () => {
    if(!audioBuffer || !segments.length){
      log('Please analyze first.'); return;
    }
    processBtn.disabled = true;
    analyzeBtn.disabled = true;
    linksEl.innerHTML = '';
    log('Stitching segments (runs locally in your browser)…');
    await new Promise(r=>setTimeout(r));

    try{
      const keepGap = parseFloat(keepgap.value);
      const outBuf = stitchToBuffer(audioBuffer, segments, keepGap);

      const format = fmtSel.value;
      if(format === 'wav'){
        log('Encoding WAV (lossless)…');
        const wavBlob = writeWAV(outBuf); // fixed header
        const url = URL.createObjectURL(wavBlob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `${baseName}_nosilence.wav`;
        a.textContent = '⬇️ Download processed WAV';
        a.className = 'dl';
        linksEl.appendChild(a);
        log(`Done. WAV length ${fmtTime(outBuf.length / outBuf.sampleRate)} @ ${outBuf.sampleRate} Hz, ${outBuf.numberOfChannels} ch.`);
      }else{
        log('Loading MP3 encoder…');
        await ensureLame();
        log('Encoding MP3 (128 kbps)…');
        const mp3Blob = encodeMP3FromAudioBuffer(outBuf, 128);
        const url = URL.createObjectURL(mp3Blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `${baseName}_nosilence.mp3`;
        a.textContent = '⬇️ Download processed MP3';
        a.className = 'dl';
        linksEl.appendChild(a);
        log(`Done. Exported MP3. Tip: You can lower bitrate in code if you want even smaller files.`);
      }
    }catch(err){
      console.error(err);
      log('Error during export: ' + err.message);
    }finally{
      processBtn.disabled = false;
      analyzeBtn.disabled = false;
    }
  });
})();
</script>
</body>
</html>