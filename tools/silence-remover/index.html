<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Silence Remover ‚Äì MP3/WAV | Userific</title>
  <meta name="description" content="Remove silence from MP3/WAV audio files online. Free, no login required. Perfect for podcasts, voiceovers, and music editing.">
  <meta name="keywords" content="silence remover, cut silence mp3, remove gaps audio, podcast silence cutter, voiceover silence remover, free audio editing, no login audio tool, Userific">
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap" rel="stylesheet">
  <style>
    :root {
      --gradient-dark: linear-gradient(135deg, #0f2027, #203a43, #2c5364);
      --gradient-light: linear-gradient(135deg, #fdfbfb 0%, #ebedee 100%);
      --card-dark: rgba(30,30,30,0.9);
      --card-light: rgba(255,255,255,0.95);
      --primary: #2a7cff;
    }
    *{margin:0;padding:0;box-sizing:border-box;font-family:'Poppins',sans-serif;}
    body{min-height:100vh;background:var(--gradient-dark);color:#f5f5f5;display:flex;flex-direction:column;}
    body.light{background:var(--gradient-light);color:#111;}
    header{padding:15px 20px;display:flex;justify-content:space-between;align-items:center;}
    header h1{font-size:1.6rem;font-weight:700;}
    header h1 a{text-decoration:none;color:inherit;}
    header .tagline{font-size:0.9rem;font-weight:400;}
    .toggle{cursor:pointer;font-size:1.5rem;}
    main{flex:1;max-width:900px;margin:1rem auto;padding:1rem;width:100%;}
    .ads{margin:1rem 0;padding:1rem;border:2px dashed #777;border-radius:12px;text-align:center;font-size:0.9rem;}
    .card{background:var(--card-dark);border-radius:16px;padding:20px;box-shadow:0 4px 12px rgba(0,0,0,0.3);}
    body.light .card{background:var(--card-light);}
    label{display:block;font-size:0.9rem;margin:12px 0 6px;}
    input[type=file], select, button{width:100%;padding:12px;border-radius:12px;border:1px solid #ccc;font-size:1rem;margin-bottom:12px;}
    button{background:var(--primary);color:#fff;font-weight:600;cursor:pointer;border:none;}
    button:disabled{opacity:0.6;cursor:not-allowed;}
    input[type=range]{width:100%;}
    .row{display:grid;grid-template-columns:1fr 100px;gap:12px;align-items:center;}
    .val{text-align:right;font-size:0.9rem;}
    #out{margin-top:1rem;padding:12px;border-radius:12px;background:rgba(0,0,0,0.3);min-height:60px;white-space:pre-wrap;}
    a.dl{display:inline-block;margin-top:12px;padding:10px 14px;border-radius:10px;background:#18222a;color:#cfeaff;text-decoration:none;font-weight:600;}
    footer{text-align:center;padding:1rem;font-size:0.85rem;margin-top:2rem;}
    footer a{color:inherit;text-decoration:underline;margin:0 5px;}
  </style>
  <script>
    let lameLoaded = false;
    async function ensureLame() {
      if (lameLoaded) return true;
      return new Promise((resolve, reject) => {
        const s = document.createElement('script');
        s.src = 'https://unpkg.com/lamejs@1.2.0/lame.min.js';
        s.onload = () => { lameLoaded = true; resolve(true); };
        s.onerror = () => reject(new Error('Failed to load MP3 encoder.'));
        document.head.appendChild(s);
      });
    }
  </script>
</head>
<body class="dark">
  <header>
    <div>
      <h1><a href="/">Userific</a></h1>
      <div class="tagline">Useful tools built just for you ‚ú®</div>
    </div>
    <div class="toggle" id="themeToggle">‚òÄÔ∏è</div>
  </header>

  <main>
    <h1>Silence Remover</h1>
    <p>Remove long silences from audio and keep only what matters. Works with MP3/WAV files. Exports in your chosen format. 100% free, secure, no login required.</p>

    <div class="ads">Ads will show here</div>

    <div class="card">
      <!-- original working UI -->
      <label>Choose MP3/WAV file</label>
      <input id="file" type="file" accept=".mp3,.wav,audio/*" />

      <div class="row">
        <div>
          <label>Silence threshold (dBFS)</label>
          <input id="thresh" type="range" min="-80" max="-10" step="1" value="-45">
        </div>
        <div class="val"><span id="threshVal">-45</span> dB</div>
      </div>

      <div class="row">
        <div>
          <label>Minimum silence to cut (seconds)</label>
          <input id="minsil" type="range" min="0.1" max="2.0" step="0.1" value="0.3">
        </div>
        <div class="val"><span id="minsilVal">0.3</span> s</div>
      </div>

      <div class="row">
        <div>
          <label>Keep gap after cut (seconds)</label>
          <input id="keepgap" type="range" min="0.2" max="1.0" step="0.1" value="0.5">
        </div>
        <div class="val"><span id="keepVal">0.5</span> s</div>
      </div>

      <div class="row">
        <button id="analyze">Analyze</button>
        <select id="format">
          <option value="mp3" selected>Export: MP3 (128 kbps)</option>
          <option value="wav">Export: WAV (lossless)</option>
        </select>
        <button id="process" disabled>Cut & Export</button>
      </div>

      <div id="out">Ready.</div>
      <div id="links"></div>
      <p class="small">Tip: If words get chopped, lower the threshold (e.g., ‚àí50 dB) or increase ‚ÄúMinimum silence‚Äù.</p>
    </div>

    <div class="ads">Ads will show here</div>
  </main>

  <footer>
    <p>&copy; <span id="year"></span> Userific.xyz ‚Äì All Rights Reserved</p>
    <p><a href="privacy.html">Privacy Policy</a> | <a href="terms.html">Terms</a> | <a href="contact.html">Contact</a></p>
  </footer>

  <!-- keep your working JS code unchanged -->
  <script>
    document.getElementById("year").textContent=new Date().getFullYear();
    const themeToggle=document.getElementById("themeToggle");
    themeToggle.addEventListener("click",()=>{
      document.body.classList.toggle("light");
      themeToggle.textContent=document.body.classList.contains("light")?'üåô':'‚òÄÔ∏è';
    });
  </script>

  <!-- üëá Your original silence remover logic -->
  <script>
const fileInput = document.getElementById("file");
const analyzeBtn = document.getElementById("analyze");
const processBtn = document.getElementById("process");
const out = document.getElementById("out");
const links = document.getElementById("links");
const threshSlider = document.getElementById("thresh");
const minSilSlider = document.getElementById("minsil");
const keepGapSlider = document.getElementById("keepgap");
const threshVal = document.getElementById("threshVal");
const minSilVal = document.getElementById("minsilVal");
const keepVal = document.getElementById("keepVal");
const formatSelect = document.getElementById("format");

let audioBuffer, cuts = [];

threshSlider.oninput = () => { threshVal.textContent = threshSlider.value; };
minSilSlider.oninput = () => { minSilVal.textContent = minSilSlider.value; };
keepGapSlider.oninput = () => { keepVal.textContent = keepGapSlider.value; };

async function decodeFile(file) {
  const ctx = new AudioContext();
  const arrayBuffer = await file.arrayBuffer();
  return await ctx.decodeAudioData(arrayBuffer);
}

function dbfs(rms) {
  return 20 * Math.log10(rms);
}

function analyzeBuffer(buffer, threshold, minSil, keepGap) {
  const data = buffer.getChannelData(0);
  const sr = buffer.sampleRate;
  const winSize = Math.floor(0.02 * sr);
  const hop = winSize;
  let silStart = null;
  cuts = [];

  for (let i = 0; i < data.length; i += hop) {
    const slice = data.slice(i, i + winSize);
    const rms = Math.sqrt(slice.reduce((s, v) => s + v*v, 0) / slice.length);
    const level = dbfs(rms || 1e-6);

    if (level < threshold) {
      if (silStart === null) silStart = i;
    } else {
      if (silStart !== null) {
        const dur = (i - silStart) / sr;
        if (dur >= minSil) {
          cuts.push([silStart / sr, i / sr]);
        }
        silStart = null;
      }
    }
  }
  return cuts;
}

analyzeBtn.onclick = async () => {
  if (!fileInput.files[0]) {
    alert("Please choose an audio file first.");
    return;
  }
  out.textContent = "Analyzing...";
  audioBuffer = await decodeFile(fileInput.files[0]);
  const threshold = parseFloat(threshSlider.value);
  const minSil = parseFloat(minSilSlider.value);
  const keepGap = parseFloat(keepGapSlider.value);
  analyzeBuffer(audioBuffer, threshold, minSil, keepGap);
  out.textContent = `Found ${cuts.length} silent segments. Ready to process.`;
  processBtn.disabled = false;
};

processBtn.onclick = async () => {
  if (!audioBuffer) return;
  out.textContent = "Processing... this may take a while.";

  const threshold = parseFloat(threshSlider.value);
  const minSil = parseFloat(minSilSlider.value);
  const keepGap = parseFloat(keepGapSlider.value);
  analyzeBuffer(audioBuffer, threshold, minSil, keepGap);

  // Cut silences
  const sr = audioBuffer.sampleRate;
  let segments = [];
  let last = 0;
  for (let [s, e] of cuts) {
    const start = Math.max(0, last);
    const end = Math.max(0, s - keepGap);
    if (end > start) segments.push([start, end]);
    last = e + keepGap;
  }
  if (last < audioBuffer.duration) segments.push([last, audioBuffer.duration]);

  const newLen = segments.reduce((s,[a,b]) => s + (b-a), 0);
  const outBuf = new AudioContext().createBuffer(1, newLen*sr, sr);
  let pos = 0;
  for (let [a,b] of segments) {
    const seg = audioBuffer.getChannelData(0).slice(a*sr, b*sr);
    outBuf.getChannelData(0).set(seg, pos);
    pos += seg.length;
  }

  const format = formatSelect.value;
  if (format === "wav") {
    // Export WAV
    const wav = audioBufferToWav(outBuf);
    const blob = new Blob([wav], { type: "audio/wav" });
    const url = URL.createObjectURL(blob);
    makeDownloadLink(url, "output.wav");
  } else {
    // Export MP3 (using lamejs)
    await ensureLame();
    const mp3encoder = new lamejs.Mp3Encoder(1, sr, 128);
    const samples = outBuf.getChannelData(0);
    let mp3Data = [];
    const maxSamples = 1152;
    for (let i = 0; i < samples.length; i += maxSamples) {
      const chunk = samples.subarray(i, i+maxSamples);
      const buf = new Int16Array(chunk.length);
      for (let j=0;j<chunk.length;j++) buf[j] = Math.max(-32768, Math.min(32767, chunk[j]*32767));
      const mp3buf = mp3encoder.encodeBuffer(buf);
      if (mp3buf.length > 0) mp3Data.push(mp3buf);
    }
    const enc = mp3encoder.flush();
    if (enc.length > 0) mp3Data.push(enc);
    const blob = new Blob(mp3Data, {type: "audio/mp3"});
    const url = URL.createObjectURL(blob);
    makeDownloadLink(url, "output.mp3");
  }

  out.textContent = "Done!";
};

function makeDownloadLink(url, name) {
  links.innerHTML = "";
  const a = document.createElement("a");
  a.href = url;
  a.download = name;
  a.textContent = "Download " + name;
  a.className = "dl";
  links.appendChild(a);
}

// Helper: audioBuffer ‚Üí WAV ArrayBuffer
function audioBufferToWav(buffer) {
  const numOfChan = buffer.numberOfChannels,
        length = buffer.length * numOfChan * 2 + 44,
        out = new ArrayBuffer(length),
        view = new DataView(out),
        channels = [],
        sampleRate = buffer.sampleRate;

  let offset = 0;
  function setUint16(data) { view.setUint16(offset, data, true); offset += 2; }
  function setUint32(data) { view.setUint32(offset, data, true); offset += 4; }

  setUint32(0x46464952); // "RIFF"
  setUint32(length - 8);
  setUint32(0x45564157); // "WAVE"
  setUint32(0x20746d66); // "fmt "
  setUint32(16);
  setUint16(1);
  setUint16(numOfChan);
  setUint32(sampleRate);
  setUint32(sampleRate * numOfChan * 2);
  setUint16(numOfChan * 2);
  setUint16(16);
  setUint32(0x61746164); // "data"
  setUint32(length - offset - 4);

  for (let i = 0; i < buffer.numberOfChannels; i++)
    channels.push(buffer.getChannelData(i));

  let interleaved = new Float32Array(buffer.length * numOfChan);
  for (let i = 0; i < buffer.length; i++)
    for (let ch = 0; ch < numOfChan; ch++)
      interleaved[i * numOfChan + ch] = channels[ch][i];

  let idx = 44;
  for (let i = 0; i < interleaved.length; i++, idx += 2) {
    let s = Math.max(-1, Math.min(1, interleaved[i]));
    view.setInt16(idx, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
  }
  return out;
}
  </script>
    // (Paste the exact working JS from silence_cutter_mp3_fixed.html here without changes)
  </script>
</body>
</html>
